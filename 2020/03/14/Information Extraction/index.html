<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Information Extraction | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="NER作为序列标记 指定的标记同时捕获边界和类型。序列分类器(如MEMM&#x2F;CRF或bi-LSTM)被训练为在文本中使用标记来标记标记，这些标记表示特定类型的命名实体的存在。  IO encoding简单的为每个 token 标注，如果不是 NE 就标为 O(other)，所以一共需要 C+1 个类别(label)。而IOB encoding需要 2C+1 个类别(label)，因为它标了 NE b">
<meta property="og:type" content="article">
<meta property="og:title" content="Information Extraction">
<meta property="og:url" content="http://yoursite.com/2020/03/14/Information%20Extraction/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="NER作为序列标记 指定的标记同时捕获边界和类型。序列分类器(如MEMM&#x2F;CRF或bi-LSTM)被训练为在文本中使用标记来标记标记，这些标记表示特定类型的命名实体的存在。  IO encoding简单的为每个 token 标注，如果不是 NE 就标为 O(other)，所以一共需要 C+1 个类别(label)。而IOB encoding需要 2C+1 个类别(label)，因为它标了 NE b">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gctgr2ewzoj30qu0ki1dr.jpg">
<meta property="article:published_time" content="2020-03-14T06:55:06.726Z">
<meta property="article:modified_time" content="2020-03-14T09:51:11.405Z">
<meta property="article:author" content="ZQ Liu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/00831rSTly1gctgr2ewzoj30qu0ki1dr.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Information Extraction" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/Information%20Extraction/" class="article-date">
  <time datetime="2020-03-14T06:55:06.726Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Information Extraction
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>NER作为序列标记</strong></p>
<p>指定的标记同时捕获边界和类型。序列分类器(如MEMM/CRF或bi-LSTM)被训练为在文本中使用标记来标记标记，这些标记表示特定类型的命名实体的存在。</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gctgr2ewzoj30qu0ki1dr.jpg" alt="image-20200314145732575"></p>
<p><strong>IO encoding</strong>简单的为每个 token 标注，如果不是 NE 就标为 O(other)，所以一共需要 C+1 个类别(label)。而<strong>IOB encoding</strong>需要 2C+1 个类别(label)，因为它标了 NE boundary，B 代表 begining，NE 开始的位置，I 代表 continue，承接上一个 NE，如果连续出现两个 B，自然就表示上一个 B 已经结束了。</p>
<ul>
<li>提取特征并训练<strong>词性标记类型的MEMM或CRF序列模型</strong></li>
</ul>
<blockquote>
<p>由于汉语的特殊性，除了词汇层面的特征外，汉字层面的特征也被充分地用来辅助提高NER的效果.</p>
<p>由于汉语分词和NER的密切联系，有研究发现分词结果可以有效地提高汉语NER的效果。</p>
<p>研究表明，在模型不变的情况下，全局信息和外部知识确实可以显著地提高识别的效果。维基百科知识是最常见且有效的外部知识，而在汉语NER中，知网作为一个汉语特有的词汇语义知识库，也被充分地应用在NER研究中。</p>
</blockquote>
<p><strong>关系抽取</strong></p>
<p><strong>关系抽取</strong>需要从文本中抽取两个或多个实体之间的语义关系，主要方法有下面几类：</p>
<ul>
<li><p><strong>基于模板的方法(hand-written patterns)</strong></p>
</li>
<li><ul>
<li>基于触发词/字符串</li>
<li>基于依存句法</li>
</ul>
</li>
<li><p><strong>监督学习(supervised machine learning)</strong></p>
</li>
<li><ul>
<li>机器学习</li>
<li>深度学习（Pipeline vs Joint Model）</li>
</ul>
</li>
<li><p><strong>半监督/无监督学习(semi-supervised and unsupervised)</strong></p>
</li>
<li><ul>
<li>Bootstrapping</li>
<li>Distant supervision</li>
<li>Unsupervised learning from the web</li>
</ul>
</li>
</ul>
<p>监督学习去做关系提取的过程如下：首先特定的关系和命名实体已经选择了，训练集语料手动去标注关系和命名实体，接着就是注释的语料就是用来去训练分类器去标注没有见过的训练集。</p>
<p>最直接的方法有3步：</p>
<ul>
<li>第一步，找寻一对命名实体。通常在一句话中。</li>
<li>第二步，二元分类器的作用是用来判断两个命名实体之间是否有关系</li>
<li>第三步，分类器将用来去标记命名实体之间的关系</li>
</ul>
<p><strong>监督学习-深度学习</strong></p>
<p>深度学习方法又分为两大类，pipeline 和 joint model</p>
<ul>
<li><strong>Pipeline</strong><br>把实体识别和关系分类作为两个完全独立的过程，不会相互影响，关系的识别依赖于实体识别的效果</li>
<li><strong>Joint Model</strong><br>实体识别和关系分类的过程共同优化</li>
</ul>
<p>深度学习用到的特征通常有：</p>
<ul>
<li>Position embeddings</li>
<li>Word embeddings</li>
<li>Knowledge embeddings</li>
</ul>
<p>模型通常有 CNN/RNN + attention，损失函数 ranking loss 要优于交叉熵。</p>
<p><strong>远程监督：</strong></p>
<p>Mintz<strong>提出一个假设</strong>，如果知识库中存在某个实体对的某种关系，那么所有包含此对实体的数据都表达这个关系。理论上，这让关系抽取的工作大大简化。但<strong>远程监督</strong>也有<strong>副作用</strong>，因为不用人为的标注，只能机械地依赖外部知识库，而外部知识库会将同一对实体的所有情况都会标注一种关系，其标签的准确度就会大大的降低。</p>
<p><strong>EALO</strong>(Expressed-at-least-once)假设：如果知识库中存在某个实体对的某种关系，那么至少有一个提到此对实体的数据表达此种关系。</p>
<p><strong>主流</strong>的<strong>关系抽取模型</strong>几乎都在使用<strong>引入多示例学习</strong>的<strong>远程监督</strong>方法，<strong>再结合</strong>深度学习,卷积神经网络（convolutional neural networks, CNN）肩负着主要任务。</p>
<p><strong>多示例学习</strong>是一种<strong>监督学习</strong>模式.可以对具有某种特征的数据样本集合打标签，这样的样本集合称为<strong>袋（bag)</strong>. 每个bag有标签，而每个bag中含有多个数据样本，每个样本即为一个示例（instance)。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/14/Information%20Extraction/" data-id="ck7yipo6v00003sjd25gq5qes" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/19/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/19/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/03/14/Information%20Extraction/">Information Extraction</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 ZQ Liu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>